---
title: "Inserting breakpoints to resolve layers"
layout: example
authordate: "Nick Trefethen, January 2016"
meta: "(Chebfun example ode-linear/Breakpoints.m) [Tags: #linearODE, #boundarylayer, #advectiondiffusion]"
---



## 1. Boundary layer example

By default, Chebfun solves BVPs with global grids -- Chebyshev collocation spectral methods -- and this generally works well even for problems with rapidly varying solutions.  Trouble appears, however, when the variations are _very_ rapid.  For example, following the example `ode-linear/BoundaryLayer`, here are solutions to the linear advection-diffusion equation $$ L_\varepsilon u = -\varepsilon u'' - u' = 1,\qquad    u(0) = u(1) = 0 , $$ with $\varepsilon = 10^{-1}, 10^{-2},\dots,  10^{-5}$

<pre class="mcode-input">dom = [0,1];
L = @(ep) chebop(@(x,u) -ep*diff(u,2) - diff(u),dom,'dirichlet');
LW = 'linewidth'; lw = 1.6; FS = 'fontsize'; MS = 'markersize';
headings = '        ep      pos(max(u))    length(u)    time (secs.) ';
disp(headings)
fs = '%12.1e %14.9f %9d %14.2f\n';
for ep = 10.^(-1:-1:-5)
  tic, u = L(ep)\1; t = toc;
  [val,pos] = max(u);
  fprintf(fs, ep, pos, length(u), t)
  plot(u,'b',LW,lw), hold on
end
grid on, axis([-0.03 1 0 1.03])
title('Boundary layers for \epsilon = 1e-1, 1e-2,..., 1e-5',FS,12)</pre><pre class="mcode-output">        ep      pos(max(u))    length(u)    time (secs.) 
     1.0e-01    0.230263049        23           2.15
     1.0e-02    0.046051702        59           0.17
     1.0e-03    0.006907755       170           0.22
     1.0e-04    0.000921034       488           0.74
     1.0e-05    0.000115129      1495           8.03
</pre><img src="img/Breakpoints_01.png" class="figure" alt=""/>

The lengths and timings are excellent for the first three values of $\varepsilon$ and not so bad for $\varepsilon = 10^{-4}$; but for $\varepsilon = 10^{-5}$ we need a grid with thousands of points and the method cannot be regarded as satisfactory. (This boundary layer is of width $(\varepsilon)$, but because of the quadratic clustering of Chebyshev grids at boundaries, the length of the chebfuns only grows like $O(\varepsilon^{-1/2})$.) There is a standard method used in scientific computing for such problems, adaptive grid refinement, but Chebfun does not have such a capability at present.

For many problems, however, it is remarkable what one can achieve by a certain ``poor man's grid refinement'': simply add a Chebfun breakpoint or two near the region of rapid change.  This is a non-adaptive, a priori approach.  It cannot cope with a full range of problems but it can do very well with many of them.  For example, here is the same problem as before with a single breakpoint introduced at $x_b = 40\varepsilon$. Just one curve is plotted, the one with $\varepsilon = 10^{-3}$.

<pre class="mcode-input">dom = @(ep) [0 min(0.5,40*ep) 1];
L = @(ep) chebop(@(x,u) -ep*diff(u,2) - diff(u),dom(ep),'dirichlet');
disp(headings), hold off
for ep = 10.^(-1:-1:-8)
  tic, u = L(ep)\1; t = toc;
  fprintf(fs, ep, pos, length(u), t)
  [val,pos] = max(u);
  if ep == 1e-3
    plot(u,'b',LW,lw), hold on
    breakpoint = u.ends(2);
    plot(breakpoint,u(breakpoint),'.r',MS,24)
  end
end
grid on, axis([-0.03 1 0 1.03])
title('The same computed with a breakpoint',FS,12)</pre><pre class="mcode-output">        ep      pos(max(u))    length(u)    time (secs.) 
     1.0e-01    0.000115129        34           0.22
     1.0e-02    0.230263049        41           0.21
     1.0e-03    0.046051702        41           0.20
     1.0e-04    0.006907755        41           0.29
     1.0e-05    0.000921034        41           0.25
     1.0e-06    0.000115129        41           0.21
     1.0e-07    0.000013816        41           0.27
     1.0e-08    0.000001612        41           2.09
</pre><img src="img/Breakpoints_02.png" class="figure" alt=""/>

Quite an amazing improvement!  Notice that the breakpoint at $x_b = 40 \varepsilon$ is well out of the boundary layer.  The reason for this choice is that the purpose of the breakpoint is not to optimize the representation of $u$ within the small region $[0, x_b]$, where a reasonable number of gridpoints will be required in any case, but rather to ensure that $u$ has no significant structure on length scale $\varepsilon$ in the big interval $[x_b,1]$. In fact, the second piece of each chebfun constructed above, the representation of $u$ on $[x_b ,1]$, is just of length 2, i.e., a linear polynomial:

<pre class="mcode-input">u</pre><pre class="mcode-output">u =
   chebfun column (2 smooth pieces)
       interval       length     endpoint values  
[       0,   4e-07]       39     3e-15        1 
[   4e-07,       1]        2         1  1.8e-12 
vertical scale =   1    Total length = 41
</pre>

## 2. Interior layer example

As our second example, we consider a linear problem with an interior layer: $$ \varepsilon u'' + xu' + xu = 0, \quad x \in [-2,2], ~ y(-2) = -4, y(2) = 2 . $$ This has an interior layer of width $O(\sqrt{\varepsilon}\kern 1pt)$ at $x=0$, which we can expect to challenge Chebfun as much as in the previous example, since the layer is thicker but the grid is no longer clustered.  An experiment confirms this prediction:

<pre class="mcode-input">dom = [-2,2];
L = @(ep) chebop(@(x,u) ep*diff(u,2)+x*diff(u)+x*u,dom,-4,2);
disp(headings), hold off
for ep = 10.^(-1:-1:-4)
  tic, u = L(ep)\0; t = toc;
  [val,pos] = max(u);
  fprintf(fs, ep, pos, length(u), t)
  plot(u,'m',LW,lw), hold on
end
grid on, axis([-2 2 -6 17])
title('Interior layers for \epsilon = 1e-1, 1e-2,..., 1e-4',FS,12)</pre><pre class="mcode-output">        ep      pos(max(u))    length(u)    time (secs.) 
     1.0e-01    0.456331114        57           0.28
     1.0e-02    0.188033044       154           0.29
     1.0e-03    0.073657588       460           0.92
     1.0e-04    0.027481095      1398          10.47
</pre><img src="img/Breakpoints_03.png" class="figure" alt=""/>

Inserting breakpoints on either side of $x=0$ improves matters greatly.  Again we plot just one of the curves, the one with $\varepsilon = 10^{-4}$.

<pre class="mcode-input">dom = @(ep) [-2 -min(.5,10*sqrt(ep)) min(.5,10*sqrt(ep)) 2];
L = @(ep) chebop(@(x,u) ep*diff(u,2)+x*diff(u)+x*u,dom(ep),-4,2);
disp(headings), hold off
for ep = 10.^(-1:-1:-8)
  tic, u = L(ep)\0; t = toc;
  [val,pos] = max(u);
  fprintf(fs, ep, pos, length(u), t)
  if ep == 1e-4
    plot(u,'m',LW,lw), hold on
    breakpoints = u.ends(2:3);
    plot(breakpoints,u(breakpoints),'.k',MS,24)
  end
end
grid on, axis([-2 2 -6 17])
title('The same computed with a pair of breakpoints',FS,12)</pre><pre class="mcode-output">        ep      pos(max(u))    length(u)    time (secs.) 
     1.0e-01    0.456331114        76           0.36
     1.0e-02    0.188033044       114           0.35
     1.0e-03    0.073657588       136           0.45
     1.0e-04    0.027481095       164           0.46
     1.0e-05    0.009892469       195           0.65
     1.0e-06    0.003473237       117           0.60
     1.0e-07    0.001198204       188           0.53
     1.0e-08    0.000408122       101           0.54
</pre><img src="img/Breakpoints_04.png" class="figure" alt=""/>

Here we see the sizes of the three pieces:

<pre class="mcode-input">u</pre><pre class="mcode-output">u =
   chebfun column (3 smooth pieces)
       interval       length     endpoint values  
[      -2,  -0.001]       11        -4    -0.54 
[  -0.001,   0.001]       80     -0.54       15 
[   0.001,       2]       10        15        2 
vertical scale =  15    Total length = 101
</pre>Users will find that inserting breakpoints is  bit of an art, and some experimentation is worthwhile.  The two examples we have given are linear, but the same technique can be applied for nonlinear problems too.

